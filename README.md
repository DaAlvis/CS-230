# CS-230
[CS 230 Project Software Design Template_Alvis.docx](https://github.com/user-attachments/files/20958363/CS.230.Project.Software.Design.Template_Alvis.docx)
Who was the client and what software did they need?

The client was The Gaming Room, a company looking to expand their multiplayer game Draw It or Lose It. The game needed to be designed so that multiple teams could compete against each other, each with multiple players. The system needed to ensure that team and game names were unique and that only one version of the game could run in memory at a time. The ultimate goal was to create a scalable, web-based game that could work across different platforms while being secure, efficient, and ready for future growth.

What did I do particularly well?

I think I did a great job breaking down the technical concepts in a way that made them easy to understand, even for non-technical stakeholders. I was able to clearly explain architectural choices and connect them back to the client’s goals. I also kept the document organized and focused, which made it easy to follow.

What about the design document process helped when developing the code?

Writing the design document before coding forced me to think carefully about the structure of the application. It helped me define the classes, their relationships, and how data would be managed before ever writing a line of code. That made development much smoother because I already had a solid plan to follow.

If I could revise one part, what would it be?

I would go back and simplify some of the more technical sections in the recommendations. While the content was accurate, I’d want to make sure every section could be easily understood by a client who might not have a technical background. I’d probably include more real-world examples or visuals to make those concepts even clearer.

How did I interpret and implement the user’s needs?

I focused on making sure the software design directly addressed the client’s goals, especially the need for one active game instance and unique identifiers for games, teams, and players. These features were implemented using object-oriented programming principles like encapsulation, inheritance, and the singleton pattern. Keeping the user’s experience and needs front and center was important for making sure the final design was functional and user-friendly.

What strategies will I use for future projects?

For future software design projects, I’ll continue to use a structured design approach that includes identifying requirements, planning class relationships, and mapping out the architecture before coding. I’ll also use tools like domain models and design patterns to help visualize and organize the system. Communicating design decisions clearly and keeping the end-user in mind will always be part of my strategy.
